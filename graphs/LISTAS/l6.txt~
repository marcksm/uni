1)**** Digamos que a antidistancia de um vertice s a um vertice t e o custo de um caminho simples de custo maximo
dentre os que vao de s a t. Modifique o algoritmo de Dijkstra da seguinte maneira: em cada iteraçao, escolha um 
vertice y na fronteira de T que maximize dist[y]. Eh verdade que essa versao modificada calcula a antidistancia
de um vertice s e cada um dos demais vertices de um grafo com custos positivos?
R) ...


2) Escreva uma funç~ao que receba conjuntos S e T de vertices de um grafo com custos positivos nos arcos
e calcule a distancia de S a T, ou seja, o custo de um caminho minimo dentre os que começam em S e terminam
em T.
R) 
Vertex {
  Vertex id;
  Vertex *next;
}

int isIn (Vertex *x, Vertex id) {
  if (x == NULL) return -1;
  if (x.id == id) return 1;
  return isIn(x->next, id);
}

int GRAPHmincostST (Graph G, Vertex *s, Vertex *v) {
  



}































